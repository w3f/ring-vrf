


\section{Security Model  of Ring VRF}
In this section, we define a ring VRF scheme in the UC framework, covering both real-world and ideal-world executions.

\begin{definition}[Ring VRF] \label{def:ringVRF}	It  is defined with public parameters $ pp $ generated by \eprint{a setup algorithm}{} $ \rVRF.\Setup(1^\secparam) $ and with the following  PPT algorithms. All algorithms below include $ pp $ as part of their input, although it may not always be explicitly stated.
	\begin{itemize}
		\item $ \rVRF.\KeyGen(pp) \rightarrow (\sk,\pk)$: It generates a secret key and public key pair $ (\sk,\pk) $ given input $ pp $.
		\item $ \rVRF.\Eval(\sk_i, \msg) \rightarrow \Out$: It is a deterministic algorithm that outputs an evaluation value $ \Out \in \setsym{S}_{eval}$ given  $ \sk_i $ and an input $ \msg $. \eprint{Here, }{}$ \setsym{S}_{eval} \in pp$ and is the domain  of  evaluation values.
	\end{itemize}
	The following algorithms need an input $ \ring = \set{\pk_1, \pk_2, \ldots, \pk_n}$\eprint{ that we call ring}{}:
	\begin{itemize}
		\item $ \rVRF.\CommitRing(\ring, \pk_i)  \rightarrow (\comring, \openring)$: It  outputs a commitment of $ \ring $ with the opening $ \openring $ given input  $ \ring $ and $ \pk \in \ring $.
		\item $ \rVRF.\OpenRing(\comring,\openring) \rightarrow \pk $: It  outputs a public key $ \pk  $ given commitment $ \comring $ and an opening $ \openring $ of $\comring$ to $\pk$.
		\item $ \rVRF.\Sign(\sk_i, \comring,\openring, \msg, \aux)\rightarrow \sigma$: It  outputs a  signature  $\sigma $  of  $ \msg, \aux \in \{0,1\}^*$ given $ \sk_i, \openring $  and $ \comring $ 
		\item $ \rVRF.\Verify(\comring,\msg,\aux,\sigma) \rightarrow  (b, \Out)$: It is a deterministic  algorithm that outputs  $ b \in \{0,1\} $ and $ \Out \in\setsym{S}_{eval}\cup \{\perp\} $. $ b =1 $ means $ \sigma $ and $ \Out $ are verified.
	\end{itemize}
	
\end{definition}


We note that $ \rVRF.\CommitRing $ and $  \rVRF.\OpenRing $ are optional algorithms of a ring VRF scheme. If they are not defined, we should let $ \comring = \ring $ and $ \openring  = \pk$. $ \rVRF.\CommitRing $ and $  \rVRF.\OpenRing $ are useful for a succinct verification process in the case of a large ring.

We summary the  security properties for $ \rVRF $  informally as follows: 
\begin{itemize}
	\item \emph{correctness}; when an honest signer with key $ (\sk_i,\pk_i) $ outputs $ \sigma $ by running $ \rVRF.\Sign(\sk_i, \comring,\openring, \msg, \aux) $, $ \rVRF.\Verify(\comring,\msg,\aux,\sigma)  $ must output $ 1,\Out = \rVRF.\Eval(\sk_i, \msg) $ given  $ \rVRF.\OpenRing(\comring,\openring) \rightarrow \pk_i \in \ring$. Indeed, while verifying the ring VRF signature, a verifier verifies that $ \aux $ is signed by one of the keys is in the ring and also verifies that  $ \Out $ is the evaluation value of $ \msg $ generated with the same key. 
	\item \emph{randomness}; $ \Out $ is random and independent from the input and the  key.
	%\item \emph{determinism} meaning that $ \rVRF.\Eval $ is deterministic,
	\item   \emph{anonymity} meaning that the output of $ \rVRF.\Sign $ does not leak any information about the key of its signer except that the key is in the ring.
	\item \emph{unforgeability}; an adversary should not be able to forge a ring VRF signature 
	\item  \emph{uniqueness}; the number of verified evaluation values should not be more than the number of the keys in the ring.
\end{itemize}



%We could define all these security properties formally in the standard model but this may cause composability issues when the ring VRF protocol is composed with other protocols. Considering the applications of ring VRF protocol, we want to achieve stronger security guarantees in different environments. Therefore, we define the security of a ring VRF scheme in the UC model in Section \ref{subsec:uc_model}. 

%One can consider a ring VRF scheme is a combination of a VRF scheme and a ring signature scheme where $ \rVRF.\Eval $ is similar to $ \Eval $ algorithm of a VRF scheme and $ \rVRF.\Sign $ is similar to $ \Sign $ algorithm of a ring signature scheme. The  subtle difference is in $ \rVRF.\Verify $ that works  similar to both $ \Verify $ of ring signature and VRF schemes.  $ \rVRF.\Verify $ does not need the signer's public key to verify a ring VRF signature as in a ring signature scheme but it outputs the signer's evaluation value for every verified signature. 
%If the evaluation value is generated independent from the signer's key, $ \rVRF.\Verify(\ring,\msg,\aux,\sigma) $ does not reveal any identity of the signer except that the signer's key is in the ring.


We remark that the output of $\rVRF.\Eval$ is independent of any specific ring.  Consequently, the verification of two signatures for a given input using different rings results in the same evaluation value.  This property allows a party to disclose their identity as needed.  For instance, suppose $\Out \leftarrow \rVRF.\Eval(\sk_i, \msg)$ is verified via a ring VRF signature $\sigma$ with a ring containing $\pk_i$.  Later, if the corresponding party wishes to affirm that $\Out$ was generated using their key, they simply need to sign the same input with a ring which consists of only their key i.e., $ \ring = \{\pk_i\} $.



%Therefore, if a signer $ \user $ with a public key $ \pk $ signs a message $ \msg $ for $ \ring $ where $ \pk \in \ring $ and obtains $ \sigma_1 $ at some point  and later wants to reveal its identity i.e.. $ \sigma_1 $ is signed by $ \user $ with $ \pk $, $ \user $ should resign $ \msg $ with another ring $ \{\pk\} $ consisting on \emph{only} its public key and obtain another signature $ \sigma_2 $. Since the verification of $ \sigma_1 $ and $ \sigma_2 $ with $ \ring $ and $ \{\pk\} $, respectively, outputs the same evaluation value, the verifier can be convinced that $ \user $ signed the both signatures. Hence, a ring VRF scheme can link the identities of the signers if it is necessary.




\paragraph{The ring VRF in the ideal world:} We introduce a ring VRF functionality $ \fgvrf $ to model execution of a ring VRF protocol in the ideal world. In other words, we define a ring VRF protocol in the case of having a trusted entity $ \fgvrf $. There are many straightforward ways of defining a ring VRF protocol in the ideal world satisfying the desired security properties. However, defining simple and intuitive functionality while being as expressive and realizable in the real world execution is usually at odds \cite{canetti1}. Therefore, we have a lengthy $ \fgvrf $ (See Figure \ref{f:gvrf}) which satisfies the security properties that we expect from a ring VRF scheme and at the same time as faithful to the reality as possible. For the sake of clarity and accessibility, we split each execution part of $ \fgvrf $ while we introduce our functionality. The composition of all parts is in Figure \ref{f:gvrf}. We first describe how $  \fgvrf $ works and then show which security properties it achieves.


$ \fgvrf $ has tables to store the data generated from the requests from honest parties and the adversary $ \simulator $. The table $ \vklist $  keeps the keys of parties. The other table  $ \anonymouskeymap $ stores an anonymous key that corresponds to an input  of a party with a key $ \pk $. We note that the real execution of a ring VRF (Definition \ref{def:ringVRF}) does not have a concept of an anonymous key but $ \fgvrf $ needs this internally to execute the verification of a ring signature. Related to anonymous keys, $ \fgvrf $ also stores  all  malicious anonymous keys in a table $ \anonymouskeylist $. Finally, $ \fgvrf $ stores the evaluations values of all parties in $ \evaluationslist $. In a nutshell,  given $ \pk $
and $ \msg $, $ \fgvrf $  generates an anonymous key $ W $ as explained below and  sets $ \anonymouskeymap[\msg,W]  $ to $ \pk $. Then, it generates an evaluation value $ \Out $ as explained below and sets $ \evaluationslist[\msg,W]  $ to $ \Out $. In short, given honestly generated secret, public key pair $ (\sk,\pk) $ in the real world, the algorithm
$ \rVRF.\Eval(\sk,\msg) $  that outputs evaluation value corresponds to generating an anonymous key $ W $ for $ \pk, \msg $ and obtaining the evaluation value stored in $ \evaluationslist[\msg,W] $ in the ideal world. The necessity and usage of all these tables and anonymous keys will be more clear while we explain $ \fgvrf $ in detail. $ \fgvrf $ consists of the following execution parts.



\paragraph{Key Generation:}  When an honest party requests  a key, $ \fgvrf $ obtains a key pair $ (\sk, \pk) $ from $ \simulator $. \eprint{$ \fgvrf $ stores them if they have not been recorded. If it is the case, }{}$ \fgvrf $ gives only $ \pk $ to the honest party. $ \fgvrf $ will later use $ \sk $ during signature generation. One can imagine $ \sk $ as a secret key and $ \pk $ as a public key but retrieving $ \sk $ from $ \simulator $ poses no issue in the ideal model. This is due to the fact that each evaluation value is randomly sampled, and a signature generated by an honest party can be considered valid if and only if they request it, as guaranteed by the verification process of $\fgvrf$.



\begin{tcolorbox}[left=2pt,right=2pt]
	\eprint{}{\scriptsize}
	\textbf{[Key Generation.]} upon receiving a message $(\oramsg{keygen}, \sid)$ from  $\user_i$, send $(\oramsg{keygen}, \sid, \user_i)$ to the simulator $\simulator$.
	Upon receiving a message $(\oramsg{verificationkey}, \sid, \sk,\pk)$ from $\simulator$, verify that $\sk $ or $\pk$ has not been recorded before for $ \sid $ in $ \vklist $. If it is the case, store  the value $\sk,\pk$ in the table $\vklist$ under $\user_i$ and return $(\oramsg{verificationkey}, \sid, \pk)$ to $ \user_i$.
\end{tcolorbox}


\paragraph{Honest Ring VRF Signature and Evaluation:} This part of $ \fgvrf $ functions for honest parties who evaluate an input $ \in $ and sign a message $ \aux $ and $ \msg $. An honest party $ \user_i $  provides to $ \fgvrf $ a ring, its own public key $ \pk_i $, $ \aux $ and  $ \msg $ to be  evaluated. Afterwards, $ \fgvrf $ generates the evaluation value of $ \msg $ and $ \pk_i $ and signs $ \msg $ and $ \aux $ for a given $ \ring $ if $ \pk_i \in \ring $. The evaluation for honest parties works as follows: If $ \fgvrf $ did not select any anonymous key for $ \msg $ and $ \pk_i $ before, it samples randomly an anonymous key $ W $ and samples randomly the evaluation value $ \Out $. The ring signature generation works as follows:  $ \fgvrf $ runs a PPT algorithm $ \Gen_{sign}(\ring, \sk,\pk,\aux,\msg) $ where $ (\sk,\pk) \in \vklist $ and obtains a signature $ \sigma $. It records $  [\msg,\aux, W, \ring,\sigma, 1]  $ for verification. Here, $ 1 $ indicates that $ \sigma  $ is a valid ring signature of $ \msg $ and $ \aux $ generated for $ \ring $ with the anonymous key $ W $.

\begin{tcolorbox}[left=2pt,right=2pt]
	\eprint{}{\scriptsize}
	\textbf{[Honest Ring VRF Signature and Evaluation.]} upon receiving a message $(\oramsg{sign}, \sid, \ring, \pk_i,\aux, \msg)$ from $\user_i$, verify that $\pk_i \in \ring$ and that there exists a public key $\pk_i$ associated to $\user_i$ in $ \vklist $. If it is not the case, just ignore the request. 	
	If there exists no $ W' $ such that $ \anonymouskeymap[\msg,W'] =  \pk_i $, let $ W \leftsample \setsym{S}_W $ and let $\Out \leftsample \setsym{S}_{eval}$. Set $ \anonymouskeymap[\msg,W] = \pk_i $ and set $ \evaluationslist[\msg, W] = \Out$.
	In any case (except ignoring), obtain $ W, \Out$ where $ \anonymouskeymap[\msg,W] =\pk_i $, $ \evaluationslist[\msg, W] = \Out$ and  $ (\sk, \pk) $ is in $\vklist $. Then run  $ \Gen_{sign}(\ring,\sk,\pk,\aux,\msg) \rightarrow \sigma $.
	%Verify that $ [\msg,\aux, W,\ring, \sigma, 0] $ is not recorded. If it is recorded, abort. Otherwise,
	Let $ \sigma = (\sigma,W)$ and record $ [\msg,\aux, W, \ring,\sigma, 1] $. Return $(\oramsg{signature}, \sid, \ring,W,\aux,\msg, \Out, \sigma)$ to $\user_i$.
\end{tcolorbox}






\paragraph{Malicious Ring VRF Evaluation:} This part is designed for $ \simulator $ to evaluate an input $ \msg $ with an anonymous key. For this,  it  provides to $ \fgvrf $  $ \msg $, a malicious key $ \pk $ and an anonymous key $ W $.  Then, $ \fgvrf $ evaluates  $ \msg $ with $ \pk $ if an anonymous key $ W' \neq W$  is not assigned to $ \msg $ and $ \pk $ before.  If it is the case, it returns the randomly selected evaluation value stored  in $ \evaluationslist[\msg, W] $. The reason of conditioning on a unique anonymous key for $ \msg $ and $ \pk $ is to prevent $ \simulator $ to obtain more than one evaluation values for $ \msg $ and $ \pk $. This is necessary for the uniqueness property.
We remark that it is possible  for $ \simulator $ to  obtain the same evaluation value of $ \msg $ with two different malicious  keys \eprint{$ \pk_i, \pk_j $}{} by sending $ (\oramsg{eval}, \sid, \pk_i, W, \msg) $ and $(\oramsg{eval}, \sid, \pk_j, W, \msg)$. However, this does not break the uniqueness.

\begin{tcolorbox}[left=2pt,right=2pt]
	\eprint{}{\scriptsize}
	\textbf{[Malicious Ring VRF Evaluation.]}  upon receiving a message $(\oramsg{eval}, \sid, \pk_i, W, \msg)$ from $\sim$, if $ \pk_i $ is recorded under an honest party's identity or if there exists $ W'\neq W $ where $ \anonymouskeymap[\msg,W'] = \pk_i $, ignore the request.
	Otherwise, record in the table $\vklist$ the value $(\perp,\pk_i)$ under $\simulator$ if $ (.,\pk_i) $ is not in $ \vklist $.
	If  $\anonymouskeymap[\msg,W]  $ is not defined before, set $ \anonymouskeymap[\msg,W] = \pk_i $ and let   $\Out \leftsample \setsym{S}_{eval}$ and set $ \evaluationslist[\msg, W] = \Out$.
	In any case (except ignoring), obtain $ \Out = \evaluationslist[\msg, W] $ and return $(\oramsg{evaluated}, \sid,  \msg, \pk_i,W, \Out)$ to $ \user_i $.
\end{tcolorbox}

We remark that if $ \simulator $ provides an anonymous key $ W $ of any honest party during  the evaluation process,  $ \simulator $ can learn the  evaluation of  $ \msg $ for this honest party without needing to know who is this party. For this, it just needs to send the message $ (\oramsg{eval}, \sid, \pk_i,W,\msg) $ where $ \pk_i $ is any  verification key. In such a case, $ \fgvrf $  returns immediately $ \evaluationslist[\msg, W] $ without checking whether $ \anonymouskeymap[\msg,W] = \pk_i $. So if   $ \anonymouskeymap[\msg,W]  $ belongs to an honest party, $ \simulator $ learns the evaluation value of some honest party but does not who they are. We note that this leakage does not contradict the desired security properties and helps us to prove our ring VRF protocols realizes $ \fgvrf $.  

\paragraph{Requests of  Signatures:} If $ \simulator $ provides $ W, \aux, \msg$, $ \simulator $  obtains all valid and stored ring signatures of $ \msg $ and $ \aux $ generated with an anonymous key $ W $.  

\begin{tcolorbox}[left=2pt,right=2pt]
	\eprint{}{\scriptsize}
	\textbf{[Malicious Requests of  Signatures.]} upon receiving a message $ (\oramsg{signs}, \sid, W, \aux,\msg) $ from $ \simulator $, obtain all existing valid signatures $ \sigma $ such that $ [\msg, \aux,W,.,\sigma, 1] $ is recorded and add them in a list $ \lst_{\sigma} $. 	Return $ (\oramsg{signs}, \sid, W,\aux,\msg, \lst_{\sigma})  $ to $ \simulator $.
\end{tcolorbox}




\paragraph{Ring VRF Verification:} This part of $ \fgvrf $ is to check whether  $ \sigma $ signs $ \msg $ and $ \aux $ for $ \ring $ with anonymous key $ W $. This part corresponds to $ \rVRF.\Verify $ in the real world ring VRF protocol. Therefore,
$ \fgvrf $ first checks various conditions to decide if the signature is valid. If the signature is verified, $ \fgvrf $ outputs $ b = 1 $ and $ \Out = \evaluationslist[\msg, W] $. Otherwise, it outputs $ b = 0 $ and $ \Out = \perp $. 


For the verification of the signature, $ \fgvrf $  first checks its records to see whether this signature is verified or unverified in its records i.e., checks  whether $ [\msg,\aux,W,\ring,\sigma, b'] $ is recorded (See  C\ref{cond-main:consistency}). If it is recorded, $ \fgvrf $ lets  $ b = b' $ to be consistent. Otherwise, it checks whether $ W $ is an anonymous key of an honest party generated for $ \msg $ (See C\ref{cond-main:differentsignature}). If it is the case, $ \fgvrf $ checks  its records whether this honest party requested signing  $ \msg $ and $ \aux $ for $ \ring $.  If there exists such record i.e., $ [\msg, \aux, W, \ring, ., 1] $, it stores the new signature $ \sigma $ as a valid signature in its records and lets $ b = 1 $. We remark that $ \simulator $ can create arbitrary verified signatures that sign any $ \msg $ and $ \aux $ for $ \ring $ with $ W $ once the honest party owning $ W $ has requested signing $ \msg $ and $ \aux $ for $ \ring $. This does not break the forgeability property because the honest party has already signed for it. 
If none of the above conditions (C\ref{cond-main:consistency} and C\ref{cond-main:differentsignature}) holds, it means that $ \sigma $ could be a signature generated for a malicious party. Therefore, $ \fgvrf $ asks about it to $ \simulator $ and $ \simulator $ replies with  a public key $ \pk_\simulator $ and an indicator $ b_\simulator $ showing that $ \sigma  $ is valid or invalid. Then, $ \fgvrf $ checks various conditions to prevent $ \simulator $ forging and violating the uniqueness. To prevent forging, it lets  directly $ b = 0 $, if $ \pk_\simulator $ is a key of an honest party. If $ \pk_\simulator $ is not an honest key, then $ \fgvrf $ checks its table $ \anonymouskeylist[\msg,\ring] $ which stores the anonymous keys of valid malicious signatures of $ \msg $ for $ \ring $. If the number of anonymous keys in $ \anonymouskeylist[\msg,\ring] $ is greater than or equal to the number of malicious keys in $ \ring $, then $ \fgvrf $ invalidates $ \sigma $ by letting $ b = 0 $. This condition guarantees  uniqueness meaning that the number of verifying evaluation values that $ \sim $ can generate for $ \msg $ with $ \ring $ is at most the  number of malicious keys in $ \ring $. If the number of malicious anonymous keys of valid signatures does not exceed the number of malicious keys in $ \ring $, then $ \fgvrf $ checks whether $ W $ is a unique anonymous key assigned to $ \msg,\pk_\simulator $ as in the ``Malicious Ring VRF Evaluation''. If $ W $ is unique then $ \fgvrf $ lets $ b = b_\simulator $.

After deciding $ b $, $ \fgvrf $ records it as $ [\msg, \aux, W,\ring,\sigma,b] $ to be able to reply with the same $ b $ for the same verification query later. If $ b = 1 $, $ \fgvrf $ returns $ \evaluationslist[\msg, W] $ as well.

\begin{tcolorbox}[left=2pt,right=2pt]
	\eprint{}{\scriptsize}
	\textbf{[Ring VRF Verification.]} upon receiving a message $(\oramsg{verify}, \sid, \ring,W, \aux, \msg, \sigma)$ from a party, do the following: 
	% \begin{list}[label={{C}}{{\arabic*}}, start = 1]
		% https://texblog.net/help/latex/ltx-260.html
		
		\begin{list}{\hspace*{1pt} C\arabic{FunCond}}{\usecounter{FunCond}\setlength\leftmargin{0.15in}}
			\item If there exits a record $ [\msg,\aux,W,\ring,\sigma, b'] $, set $ b = b' $. 
			%(This condition guarantees the completeness and consistency.)
			%					\item Else if $ \pk  $ is an honest verification key where $ \anonymouskeymap[W] = (.,., \pk) $ and there exists no record $ [m, \ring, W, \sigma', 1] $ for any $ \sigma' $, then let $ b= 0  $.
			%					(This condition guarantees unforgeability meaning that if an honest party never signs a message $ m $ for a ring $ \ring $, then the verification fails.)\label{cond-main:forgery}
			
			%\item Else if there exists a record  such as $ [m,W,\ring,\sigma, b'] $, set $ b = b' $. (This condition guarantees consistency meaning that all identical verification requests will output the same $ b $) 
			\label{cond-main:consistency}
			\item Else if $ \anonymouskeymap[\msg,W]  $ is an honest verification key and  there exists a record $ [\msg,\aux, W,\ring, \sigma', 1] $ for any $ \sigma' $, then let $ b=1 $ and record $ [\msg,\aux, W,\ring,\sigma, 1] $. 
			%(This condition guarantees that if $ \msg $ is signed by an honest party for the ring $ \ring $ at some point, then the signature is $ \sigma' \neq \sigma $ which is generated by the adversary is valid) 
			\label{cond-main:differentsignature}
			
			\item \label{cond-main:malicioussignature}Else relay the message $(\oramsg{verify}, \sid, \ring,W,\aux, \msg, \sigma)$ to $ \simulator $ and receive back the message $(\oramsg{verified}, \sid, \ring,W,\aux, \msg, \sigma, b_{\simulator}, \pk_\simulator)$.  Then check the following:
			
			\begin{enumerate}
				\item If   $ \pk_\simulator $ is an honest verification key, set $ b = 0 $. 
				% (This condition guarantees unforgeability meaning that if an honest party never signs a message $ \msg$ for a ring $ \ring $)
				\label{cond-main:forgery}
				
				\item Else if $ W \notin \anonymouskeylist[\msg,\ring] $ and $ |\anonymouskeylist[\msg, \ring]| \geq |\ring_{mal}| $ where $ \ring_{mal} $ is a set of malicious keys in $ \ring $, set $ b = 0 $.
				%(This condition guarantees  uniqueness meaning that the number of verifying outputs that $ \sim $ can generate for $ \msg, \ring $ is at most the  number of malicious keys in $ \ring $.)
				\label{cond-main:uniqueness}.
				%\item \label{cond-main:forgerymalicious}Else if there exists $ \anonymouskeymap[W] = (m', \ring',.)  $ where $ (m', \ring') \neq (m, \ring) $ or $ \counter[m, \ring] > |\ring_m| $ where $ \ring_m $ is a set of keys in $ \ring $ which are not honest or $ b_{\simulator} = 0 $ or $ \pk_\simulator $ belongs to an honest party, set $ b = 0 $ and record $ [m, \ring,W,\sigma, 0] $. (This condition guarantees that if $ W $ is an anonymous key of a different message and ring or the number of anonymous keys of malicious parties in $ \ring $ is more than their number or     $ \simulator $ does not verify $ \sigma $, then the verification fails.)
				
				\item Else if there exists $ W' \neq W $ where  $ \anonymouskeymap[\msg,W'] = \pk_\simulator $, set $ b = 0 $. \label{cond-main:differentWforsamepk} 
				%(This condition guarantees that there exists a unique anonymous key for each $ (\msg, \pk_\simulator) $)
				\item Else set $ b = b_\sim$. \label{cond-main:simulatorbit}
			\end{enumerate}		
			
		\end{list}
		In the end,  record $ [\msg,\aux,W,\ring,\sigma, 0] $ if it is not stored. If $ b = 0 $, let $\Out = \perp $. Otherwise,   do the following:
		\begin{itemize}
			\item if $ W \notin \anonymouskeylist[\msg,\ring] $, add $ W $ to $ \anonymouskeylist[\msg,\ring]  $.
			%\item if $ \pk_\simulator $ is not recorded, record it in $ \vklist $ under $ \simulator $.
			\item if $ \evaluationslist[\msg,W] $ is not defined, sample $ y \leftsample \setsym{S}_{eval}$. Then, set $ \anonymouskeymap[\msg,W]  = \pk_\simulator$ and $ \evaluationslist[\msg, W] = \Out$.
			\item otherwise, set $ \Out = \evaluationslist[\msg, W]$. 	
		\end{itemize}
		Finally, output $(\oramsg{verified}, \sid, \ring,W, \aux,\msg, \sigma, \Out, b)$ to the party.
		
	\end{tcolorbox}
	
	In the real-world ring VRF, the verification algorithm outputs the corresponding evaluation value of the signer. Therefore, $ \fgvrf $  outputs the signer's evaluation value if the signature is verified. However, it achieves this together with the anonymous key which is not defined in the ring VRF in the real world.  If $ \fgvrf $ did not define an anonymous key for  each signature, then there would be no way that $ \fgvrf $ determines the signer's key and outputs the evaluation value because $ \sigma $ does not need to be unique for each key. Therefore, $ \fgvrf $ maps a random and independent anonymous key to each $ \msg $ and $ \pk $ so that this key behaves as if it is the verification key of the signature. Since it  is  random and independent from $ \msg $ and $ \pk $, it does not leak any information about the party during the verification but it still allows $ \fgvrf $ to distinguish the signer.
	
	We remark that when $ \fgvrf $ is in C\ref{cond-main:malicioussignature}, it does not check whether the provided public key $ \pk_\simulator $ is in the ring. This allows $\simulator$ to generate a signature of $\msg$ for $\ring$ that is signed by $\pk_\simulator$, even if $\pk_\simulator$ is not necessarily a part of $\ring$. However, it does not break any security properties that we aim for a ring VRF scheme as it can be seen in the analysis of $ \fgvrf $ below.
	% Instead checking whether the key is in the ring, it checks
	%number of anonymous keys of malicious verified signatures for $ \ring $ and $ \msg $ to make sure that the verified malicious signatures of $ \msg $ for $ \ring $ do not output evaluation values more than malicious keys in $ \ring $ to preserve the uniqueness. 
	
	\paragraph{Corruption:} $ \simulator $ can corrupt any honest party at any time.  \eprint{So, $ \fgvrf $ provides security against an adaptive adversary.}{}
	
	\begin{tcolorbox}[left=2pt,right=2pt]
		\eprint{}{\scriptsize}
		\textbf{[Corruption:] } 
		upon receiving $ (\oramsg{corrupt}, \sid, \user_i) $ from $ \simulator $, remove $ (x_i,\pk_i) $ from $ \vklist[\user_i] $ and store them to $ \vklist $ under $ \sim $. Return $ (\oramsg{corrupted}, \sid,\user_i) $.
	\end{tcolorbox}
	%In $\fgvrf$, we suppress
	%associated data and ring commitment details to make our UC functionality
	%more accessible, meaning our ring commitment is simply the full ring. We introduce more variations of ring VRF functionalities in Appendix \ref{sec:morefuncs} with additional security properties.
	%Here are several important remarks that help elucidate $\fgvrf$ in Figure \ref{f:gvrf}:
	
	
	%
	%\begin{enumerate}[label={{R-} }{{\arabic*}}, start = 1]
	%	\item Each party is distinguished by a unique verification key which is given by the simulator. Verification keys have the identifier role of  the signatures and outputs rather than  influencing the value of them. Therefore, there exists no secret key as in the real world protocol. \eprint{We note that we need to define verification keys in $ \fgvrf $ because the real world protocol $ \rVRF $ defines a verification key (or public key) for each party.}{}
	%	
	%	\item In ring VRF, the verification algorithm outputs the corresponding evaluation value of the verified signature. Therefore, $ \fgvrf $  outputs the corresponding output during the signature verification if the signature is verified. However, it achieves this together with the anonymous key which is not defined in the ring VRF in the real world.  If $ \fgvrf $ did not define an anonymous key of each signature, then there would be no way that $ \fgvrf $ determines the actual verification key of the signature $ \sigma $ and outputs the evaluation value because $ \sigma $ does not need to be associated with the signer's key. Therefore, $ \fgvrf $ maps a random anonymous key to each $ \msg $ and $ \pk $ so that this key behaves as if it is the verification key of the signature. Since it  is  random and independent from $ \msg $ and $ \pk $, it does not leak any information about the signer during the verification but it still allows $ \fgvrf $ to distinguish the signer.
	%	
	%	\item $ \fgvrf $ does not have a separate signing protocol for malicious parties as honest parties because they can generate it as they want. If they generate a signature, it is added to the $ \fgvrf $'s records as valid or invalid when an honest party sends a verification message of it.  Its validity depends on $ \simulator $ as it can be seen in  the condition C\ref{cond-main:malicioussignature} in Figure \ref{f:gvrf}. 
	%	
	%	\item Once $ \simulator $ obtains an anonymous key $ W $ of a message $ \msg $ generated for an honest party with a key $ \pk $, we let $ \simulator $ learn the  evaluation of  $ \msg $ with $ \pk $ without knowing the $ \pk $. $ \simulator $ can do this via malicious ring VRF evaluation i.e., send the message $ (\oramsg{eval}, \sid, \pk_i,W,\msg) $ where $ \pk_i $ is a malicious verification key. Here, if $ W $ is an anonymous key of $ \msg, \pk  $, $ \fgvrf $ returns $ \evaluationslist[\msg, W] $ even if $ \pk \neq \pk_i $. 
	%	%$ \fgvrf $ returns it independent from which verification key given in $ \simulator $'s message. 
	%	
	%	\item Once $ \simulator $ obtains an anonymous key of a message $ \msg $ generated for an honest party, it can learn all valid signatures generated by $ W $ for a ring $ \ring $ and $ \msg $ via malicious requests of signatures.
	%	
	%	\item Each honest party's public key $ \pk $ is associated with a unique key $ x $ which is only used to generate honest signatures by $ \Gen_{sign} $. It is never shared with honest parties. It corresponds to the secret key of $ \pk $ in the real protocol in our instantiation of $ \Gen_{sign} $ (Algorithm \ref{alg:gensign}). Since an honest signature can be only generated by honest parties (showed below), even if $ x $ is a secret key, it does not help $ \simulator $ to generate forgeries in the ideal world.
	%	
	%\end{enumerate}
	% The functionality lets parties generate a key (Key Generation), evaluate a message with the party's key (Ring VRF Evaluation), sign a message by one of the keys (Ring VRF signature) and verify the signature and obtain the evaluation output without knowing the key used for the signature and evaluation (Ring VRF Verification). 
	%
	%%We also define linking procedures in $ \fgvrf $ to link a signature with its associated key. So, if a party wants to reveal its identity at some point, it can use the linking process to show that the evaluation is executed with its key (Linking Signature). Later on, anyone can verify the linking signature (Linking Verification).
	%
	%In a nutshell, the functionality $\fgvrf$, when given as input a message $m$ and a key set $\ring$ (that we call a ring) of party, allows to create $n$ possible different outputs pseudo-random that appear independent from the inputs. The output can be verified to have been computed correctly by one of the participants in $\ring$ without revealing who they are. At a later stage, the author of the ring VRF output can prove that the output was generated by him and no other participant could have done so.
	
	
	This is the end of description $ \fgvrf $.  It is not immediately evident which security properties our functionality provides. Therefore, we  now proceed to analyse these properties. Throughout our analysis,  the evaluation value of $ (\msg, \pk_i) $ refers to $ \evaluationslist[\msg,W] $ where $ \anonymouskeymap[\msg,W] = \pk_i $.
	

	\paragraph{Randomness:} $ \fgvrf $  satisfies the following randomness property: The evaluation value of $ (\msg, \pk_i) $ is independently and randomly selected for all honest keys $\pk_i$.
	Likewise, the evaluation value of pairs ${(\msg, \pk_i)}$ with an anonymous key $W$ provided by $\simulator$ is also randomly selected independently for all malicious keys $\pk_i$.  We remark that since $ \simulator $ can provide the same anonymous key for different public keys for the same input $ \msg $, we consider the randomness of an evaluation value that is generated for all pairs $ \{(\msg, \pk_i)\} $ sharing the same anonymous key in the case of malicious evaluations.
	
	%Given that the evaluation of $  m, \pk  $ for any verification key $ \pk $ and for any message $ m $ has never been given to $ \simulator $, the probability that $ \simulator $ guesses the evaluation of $ m, \pk_i $ is $ \frac{1}{2^{\ell_\rvrf}} $, given that $  $
	
	%Evaluation of $ (\msg, \pk_i) $ where $ \pk_i $ is an honest key is generated by first assigning a random anonymous key $ W $ to it and then assigning a random evaluation value $ y $ to $ (\msg, W)$. So, honest evaluations are always random and independent from $ (\msg,\pk_i) $. Malicious evaluation value of pairs $ \{(\msg, \pk_i)\} $ with the same anonymous $ W $ is $ \evaluationslist[\msg,W] $ which is sampled randomly and independently from $ \{(\msg,\pk_i)\} $ by $ \fgvrf $.
	
	
	
	
	\paragraph{Determinism:} $ \fgvrf $  satisfies that the evaluation value  of $ (\msg, \pk_i) $, once it has been evaluated, is unique and  cannot be changed. 
	
	%$ \fgvrf $ satisfies determinism because it checks whether $ (\msg, \pk_i) $ is evaluated before every time that it needs it. The evaluation of $ (\msg, \pk_i) $ could be changed by changing the anonymous key of $ (\msg, \pk_i)  $ but the anonymous keys cannot be changed similarly once it is set. 
	The reason of it is that once an anonymous key $ W $ is assigned to $ (\msg, \pk_i) $, it cannot be updated. Therefore, when this happen, $ \evaluationslist[\msg, W] $ is fixed leading to output always the same evaluation value.
	
	\paragraph{Unforgeability:}  If an honest party with a public key $ \pk $ never signs an input $ \msg $  and an associated data $ \aux $ for a $ \ring $, then no other party can generate a  forgery of $ \msg $ and $ \aux $ for $ \ring $ signed by $ \pk $. Formally, if an honest party with $ \pk $ never sends a message $(\oramsg{sign}, \sid, \ring, \pk,\aux, \msg)$ for some $ \ring, \msg, \aux $, then  no party can create a record $ [\msg, \aux,W,\ring, ., 1] $ in $ \fgvrf $  where $ \anonymouskeymap[\msg,\pk] = W $.
	
	%We need verify that $ \sim $ cannot generate a signature $ \sigma $ that signs a message $ m $ for a ring $ \ring $ by an honest party's key $ \pk $. In other words, we need to verify that if $ \fgvrf $ never received a message $ (\oramsg{sign}, \sid,\ring,\pk,m) $ from an honest party $ \user $ with the key $ \pk $, $ \fgvrf $ cannot have a record $ [m, W, \ring, \sigma, 1] $ such that $ \anonymouskeymap[m,W]  = \pk$ (meaning that $ \sigma $ is a valid signature generated by the honest key $ \pk $). 
	To analyse this, we need to check the places where $ \fgvrf $ records a valid signature for an honest party. The first place is during the process of honest ring VRF signature and evaluation. Here, $ \fgvrf $ records a valid signature if an honest party having a key $ \pk $ sends a message $ (\oramsg{sign}, \sid,\ring,\pk,\aux,\msg) $ to $ \fgvrf $. Therefore, 	$ \sim $ cannot create a forgery there.
	The other place is during the verification process. $ \fgvrf $ creates a valid signature record in C\ref{cond-main:differentsignature} if the corresponding honest party has already signed for $ \msg, \aux $ for $ \ring $. So, forgery is not possible  in C\ref{cond-main:differentsignature} as well. It also creates a valid signature record in C\ref{cond-main:malicioussignature}. However, $ \fgvrf $ never records a valid signature  for an honest party here because it forbids it by C3-\ref{cond-main:forgery}.
	
	
	%$ \sim $ cannot create a forgery by sending a message $ (\oramsg{sign}, \sid,\ring,\pk,\aux,\msg) $ to $ \fgvrf $ because $ \fgvrf $ checks whether the sender's key is $ \pk $ to generate a signature. Another way for $ \sim $ to create a forgery is by sending an honest key $ \pk_\simulator $  in C\ref{cond-main:malicioussignature}. However, this is also not allowed by $ \fgvrf $ in condition C3-\ref{cond-main:forgery}.\eprint{ So, the only way that $ \fgvrf $ has a record $ [\msg, \aux,W,\ring, \sigma, 1] $ where $ \anonymouskeymap[\msg,\pk] = W $ is receiving a message $ (\oramsg{sign}, \sid,\ring,\pk,\aux,\msg)  $ from the honest party $\user  $ with key $ \pk $. Therefore, forgery is not possible in $ \fgvrf $.}{}
	
	\paragraph{Uniqueness:} An evaluation value $ \Out $ for an input $ \msg $  is verified with $ \ring $, if there exists a signature $ \sigma $ such that $ \fgvrf$ returns $ (\Out, 1)$ for a query $ (\oramsg{verify}, \sid, \ring,W,\aux,\msg,\sigma)$ for some anonymous key $ W $ and message $\aux $. The uniqueness property guarantees that the number of verified evaluation values of an input $ \msg $ with $ \ring $ is not more than $ |\ring| $. $ \fgvrf $ satisfies uniqueness:
	
	If $ \fgvrf $ outputs $ (1,\Out) $ for a query $ (\oramsg{verify}, \sid, \ring,W,.,\msg,\sigma)$, it means that there exists a record $ [\msg, ., W,\ring, \sigma,1] $ and $ \Out = \evaluationslist[\msg, W] $, $ \anonymouskeymap[\msg, W]  = \pk$.  If $ \pk $ is an honest key, then it means that $ \pk \in \ring $ because $ \fgvrf $ generates a signature for an honest party with a key if $ \pk \in \ring $. Now,  let's assume $ \fgvrf $ does not satisfy uniqueness i.e.,
	there exist $ t$ different verified evaluation values $ \setsym{O} = \{\Out_1, \Out_2, \ldots, \Out_t\} $ of an input $ \msg $ with $ \ring $ where $ |\ring| = t-1 $. This implies that for each $ \Out_i \in \setsym{O} $, there exists a  record $ [\msg, ., W_i,\ring,\sigma_i,1] $ such that  $\evaluationslist[\msg,W_i] = \Out_i $ where $ \anonymouskeymap[\msg,W_i] = \pk_i $ and $ W_i \neq W_j $ for all $ i,j \in [1,t] $. Since $ \fgvrf $ makes sure that there cannot be two different anonymous keys mapping to same $ (\msg, \pk) $,  $ \pk_i \neq \pk_j $ for all $ i \neq j \in [1,t] $.
	If $ \pk_i $ is an honest key, it means that $ \sigma_i $ is not a forgery so $ \pk_i \in \ring $. Therefore, each honest evaluation value  in $ \setsym{O} $ maps to one honest public key in $ \ring $ meaning that honest evaluation values in $ \setsym{O} $ is at most $ |\ring \setminus \ring_{mal}| = n_h $. If $ \pk_i $ is not an honest  key, $ W_i \in \anonymouskeylist[\msg,\ring] $ since $ \fgvrf $ adds $ W_i $ to $ \anonymouskeylist[\msg, \ring] $ whenever it creates such record for a malicious signature. $ \fgvrf $ makes sure that in the condition C3-\ref{cond-main:uniqueness} that $ \anonymouskeylist[\msg,\ring] \leq |\ring_{mal}| = n_m$. Therefore, $ t \leq n_h + n_m = |\ring| $ which is a contradiction.
	
	%We note that $ \simulator $ can generate a valid ring signature $ \sigma $ that signs $ \msg $ with a malicious key $ \pk $ for $ \ring $ where $ \pk \notin \ring $ i.e.,  $ \fgvrf $  can have a record for a malicious signature $ \sigma $ such that $ [\msg, ., W_i,\ring,\sigma,1] $ and $ \anonymouskeymap[\msg,W]  = \pk \notin \ring$. However, it cannot create signatures of $ \msg $ for $ \ring $ which $ \fgvrf $ verifies and outputs more than  $ |\ring_{mal}| $  different evaluation values.  
	
	
	
	%
	% Clearly, in this case, $ W_i \neq W_j $ for all $ i \neq j $ since $ y_i \neq y_j $ by our assumption. The number of verified honest signatures in $ \setsym{S} $ cannot be more than number of honest verification keys in $ \ring $ because $ \fgvrf $ generates a signature for an honest party if the honest key is in the ring. Since each $ \msg,\pk $ is mapped to one unique evaluation value,
	%
	%Also, it generates a unique anonymous key for each pair $ \msg,\pk $. So, if an honest signature for $ \msg,\ring $ is verified it means that the honest verification key $ \pk $ is in $ \ring $ and $ (\msg,\pk) $ has a unique anonymous key so that unique evaluation output. Therefore, the number of anonymous keys (so that evaluation outputs) for the honest signatures is at most number of honest keys in $ \ring $. Since we know that once anonymous key $ W_i $ is set for $ m, \pk_i $, it cannot be changed. This means that there exist at least $ |\ring_{mal}| + 1 $ signatures in $ \setsym{S} $. When $ \fgvrf $ verifies a malicious signature, it checks in the condition C3-\ref{cond-main:uniqueness} how many malicious anonymous keys generated for malicious signatures of $ m, \ring $ so far. If it is more that $ |\ring_{mal}| $, $ \fgvrf $ does not verify it so that it does not output an evaluation value during such signature verification. Therefore, the simulator can generate at most $ |\ring_{mal}| $ anonymous keys for verified signatures for $ \ring $. This implies that the number of verified outputs of malicious parties   is $ |\ring_{mal}| $. 
	
	\eprint{\paragraph{Robustness:} $ \simulator $ cannot prevent an honest party to evaluate, sign or verify.
		The only place that $ \fgvrf $ does not respond any query is when it aborts. It happens when it selects an honest anonymous key which already existed. This happens in negligible probability in $ \secparam $. }{}
	
	
	\paragraph{Anonymity:} We expect from an anonymous $ \fgvrf $  to adhere to the condition that an honest signature $\sigma$ generated for an input $\msg$ with $ \Gen_{sign} $ along with its associated anonymous key $W$ should not give any information regarding the honest party's key, except for the fact that it is a member of $ \ring $.  However, this condition should hold unless $\msg$ has been signed by the same party for any other  ring. In such a case,  since both signatures includes $ W $, the anonymity may be compromised  i.e.,  $ \simulator $  learns the party's key is in the intersection of $ \ring $ and $ \ring' $. We note that this design choice is intentional, as it provides parties with the flexibility to reveal their identity when necessary.
		
	It is evident that anonymous keys do not give any information related to honest party's key as they are randomly sampled by $ \fgvrf $. However, this cannot be conclusively asserted for the signatures, because it depends on the specification of $ \Gen_{sign} $. Therefore, we introduce an anonymity definition (See Definition \ref{def:anonymity}) for $ \Gen_{sign} $ and establish that $ \fgvrf $ is anonymous if $ \Gen_{sign} $ is anonymous according to this definition.
	

	
%	\begin{definition}[Anonymity]\label{def:anonymity} We define the anonymity game against a special environment $ \mathcal{D} $ which plays the following anonymity game.
%	We define the anonymity game between a challenger and $ \mathcal{D} $.  $\mathcal{D}$ accesses a signing oracle $ \mathcal{O}_{Sign} $ and $ \fgvrf $ simulated by the challenger as described in Figure \ref{f:gvrf}. 
%		\begin{itemize}
%			\item Given the input $ '\mathsf{keygen}' $, $\mathcal{O}_{Sign} $ sends $ (\oramsg{keygen, \sid}) $ to the challenger and obtains a verification key $ \pk $. Then, it stores $ \pk $ to a list $ \mathcal{K} $ and outputs $ \pk $.
%			\item Given the input $ '(\pk,\ring,\aux,\msg)' $, $ \mathcal{O}_{Sign} $ sends $ (\oramsg{sign}, \sid,\ring,\pk, \aux, \msg) $ to the challenger and receives $ (\oramsg{signature}, \sid, \ring, W,\aux, \msg, y, \sigma) $ if $ \pk \in \ring $.  Then $ \mathcal{O}_{Sign} $ stores $ \msg $ to a list $ \arraysym{signed}[\pk]  $.
%			% and $ W  $ to a list $ \anonymouskeylist $. 
%			It outputs $ (\sigma,W) $. Otherwise, it outputs $ \perp $.
%		\end{itemize}
%		At some point,	
%		$ \mathcal{D} $ sends $ (\ring, \pk_0, \pk_1, \msg,\aux)$ to  the challenger where $ \pk_0, \pk_1 \in \ring $, $ \msg  \notin \arraysym{signed}[\pk_0]$ and $ \msg  \notin \arraysym{signed}[\pk_1] $\footnote{The challenger needs to check this because if $ \msg $ is signed before by one of $ \pk_0,\pk_1 $, then the anonymity is broken trivially because verification of any signature of $ \msg $ for different rings outputs the same evaluation value}.  Challenger lets $ b \leftarrow_r\bin$. Then it gives the input $ (\pk_b, \ring, \msg,\aux) $ to $ \ora{Sign} $ and receives either $ \perp $ or $(\sigma,W)$. If it is $ (\sigma,W) $, it sends $ (\sigma,W) $ to $ \mathcal{D} $ as a challenge.
%		If $ \mathcal{D} $ sends $ '(\pk,\ring,\aux,\msg)' $ to $ \mathcal{O}_{Sign} $ where $ \pk = \pk_0 $ or $ \pk = \pk_1 $, it loses the game. 
%		During the game if $ \mathcal{D} $ outputs $ b' = b $, $ \mathcal{D} $ wins.
%		
%		$ \fgvrf $ satisfies anonymity, if any PPT distinguisher $ \mathcal{D} $ has a negligible advantage in $ \secparam $ to win the anonymity game defined as follows:
%		
%	\end{definition}
	
	\begin{definition}[Anonymity of $ \Gen_{sign} $]\label{def:anonymity}
		We define an anonymity game between a PPT distinguisher $ \mathcal{D} $ and a challenger.
		In the game, $\mathcal{D}$ sends the query  $ (\oramsg{challenge}, \ring, (\sk_0,\pk_0), (\sk_1, \pk_1), \msg,\aux)$. Then the challenger checks if  $ \pk_0, \pk_1 \in \ring $. If it is the case, the challenger samples randomly  $ b\in \{0,1\}  $ and runs $ \Gen_{sign}(\ring, \sk_b, \pk_b,\aux, \msg) \rightarrow \sigma_b $. It gives $ \sigma_b $ as a challenge to $ \mathcal{D} $. In the end of the game, if $ \mathcal{D} $ outputs $ b' = b $, then wins the game.
			
		We say that $ \Gen_{sign} $ is anonymous  if any PPT distinguisher $ \mathcal{D} $ has a negligible advantage in $ \secparam $ to win the anonymity game.
		%TODO Specify the sec param for the functionality
	\end{definition}
	
	%	We remark that $ \mathcal{D} $ generates keys of honest parties and forwards them via dummy adversaries in the ideal model. So, $ \Gen_{sign} $ of $ \fgvrf $ should be defined in a way that it preserves the anonymity even if $ \mathcal{D} $ generates the keys.
	
	
	%
	%to make $ \fgvrf $ set $ \anonymouskeymap[m,W] $ with an honest key for any $ m,W $.  Let's see whether this is possible. The places that $ \fgvrf $ can set $ \anonymouskeymap[m,W] = \pk $  is during ``malicious ring VRF evaluation", ``honest ring VRF signature and evaluation" and ``verification". Clearly, this event cannot happen via malicious ring VRF evaluation  because $ \pk $ is an honest key. It cannot happen via  ``honest ring VRF signature and evaluation''  because we assume that the party $ \user $ with the key $ \pk $ never asked for it. It cannot happen via ``verification'' because \ref{cond:forgery} prevents $ \simulator $ to generate an anonymous key for $ \pk $.      This shows us that $ \simulator $ cannot generate a signature.
	
	%
	% to generate a valid signature is via verification i.e., when a party sends a message  $ (\oramsg{verify}, \sid,\ring,W,m, \sigma) $ to $ \fgvrf $.  During the verification, if $ \fgvrf $ is in \ref{cond:differentsignature} and \ref{cond:simulatorbit} then the validity of the signature is decided by $ \simulator $. If $ \fgvrf $ is in \ref{cond:simulatorbit}, it means that there exists no $ \anonymouskeymap[m,W] = \pk \in \mathcal{P}_H $ because if it existed, $ \fgvrf $ would be in \ref{cond:differentsignature}. Therefore, the signature verified in \ref{cond:simulatorbit} cannot be a signature of an honest party's key.  This means that $ \simulator $ cannot generate a forgery via \ref{cond:simulatorbit}. So, the only left way for $ \simulator $ to generate a forgery is via \ref{cond:differentsignature}.
	%If $ \fgvrf $ is in \ref{cond:differentsignature}, then $ \anonymouskeymap[m,W] $ belongs to an honest party and another signature $ \sigma' \neq \sigma $ has already been stored as valid for $ W, \ring, m $.  If $ \sigma' $ is not generated by this honest party, then it means that $ \simulator $ forges. Let's see whether this is possible. If there exists a record $ [m, W, \ring, \sigma',1] $ , it means that $ \anonymouskeymap[m,W] = \pk \in \mathcal{P}_H$ exists. The places that $ \fgvrf $ can set $ \anonymouskeymap[m,W] = \pk $  is during ``malicious ring VRF evaluation", ``honest ring VRF signature and evaluation" and ``verification". Clearly, this event cannot happen via malicious ring VRF evaluation  because $ \pk $ is an honest key. It cannot happen via  ``honest ring VRF signature and evaluation''  because we assume that the party $ \user $ with the key $ \pk $ never asked for it. It cannot happen via ``verification'' because \ref{cond:forgery} prevents $ \simulator $ to generate an anonymous key for $ \pk $.      This shows us that $ \simulator $ cannot generate a signature via \ref{cond:differentsignature}.
	
	
	
	%Now, we verify that $ \fgvrf $ satisfies these properties. During our analysis, when we say that a message $ m $ signed by an anonymous key $ W $ we mean that $ [m,W,.,.,1] $ is recorded. We say that the signature is honest if $ \anonymouskeymap[m,W] = \pk $ is an honest party's key.
	%
	%
	%
	%\paragraph{\textbf{Uniqueness:}}
	%
	%\paragraph{\textbf{Robustness:}} We check whether $ \simulator$ can prevent an honest party signing and verifying. $ \fgvrf $ does not abort during the verification so an honest party can verify all signatures. $ \fgvrf $ aborts during the honest signing process if $ \gen_{sign}(m, \ring) $ generates a signature which was invalidated before i.e., there exists a record $ [m, W, \ring, \sigma,0] $.
	%
	%
	%
	%
	%\begin{enumerate}[label={{R-} }{{\arabic*}}, start = 1]
	%
	%%\item The ring VRF signature does not need to be random but it must be \emph{unique}  for its ring and the message. The reason of it to have a mapping from a ring VRF signature to its evaluation output. The map is necessary for $ \fgvrf $ to output the corresponding evaluation value for the signature during the verification process i.e, $ [m, \ring, \sigma] \rightarrow \pk, \evaluationsecretlist[m, \ring][\pk] \rightarrow y $.
	%\item In classical VRF, a VRF $ F $ is a deterministic function which maps a message and a public key to a random output. While in ring VRF, a message, a public key and a ring map to a random value, the verification algorithm of a ring VRF does not take the key as an input because it should be hidden. Therefore, the verification should be executed without the public key.  So, the functionality $ \fgvrf $ needs to find a way to verify the ring VRF output of a message, a public key and a ring map without knowing the public key. Because of this, $ \fgvrf $ generates an anonymized key $ W $ for each evaluation so that a message $ m $  and $ W $ maps to the random output. One can imagine this  as if a VRF output is generated with the input message $ m $ and the key $ W $ as in classical VRF i.e.,  $ F(m, W) $. 
	%
	%\item  If an honest party signs a message for a ring and obtains a signature, $ \fgvrf $ allows the simulator to generate another signature in \ref{cond-main:differentsignature} if the simulator wants. We remark that this is not a security issue because an honest party has already committed to sign the message.  A similar condition  exists in the EUF-CMA secure signature functionality $ \fsig $ \cite{canettiFsig}.
	%
	%\item \ref{cond-main:simulatorbit} of the ring VRF verification process covers the case where the adversary decides whether accepting the signature generated for its key if  it could be a valid signature for the ring i.e., the malicious key is in the ring and the anonymous key in the verification request is unique.
	%
	%\item The linking signature and the linking verification works similar to the EUF-CMA secure signature functionality $ \fsig $ \cite{canettiFsig}.
	
	
	%\end{enumerate}
	
	
	%\begin{definition}[Anonymous $ \fgvrf $]\label{def:anonymity}
	%	We call that $ \fgvrf $ is anonymous if the outputs of $ \gen_{sign} $ and $ \gen_W $ are pseudo-random.
	%	%TODO define this more formally.
	%\end{definition}
	
	
	%
	%Below, we define the real-world execution of a ring VRF.
	%\begin{definition}[Ring-VRF (rVRF)]\label{def:ringvrf}
	%	%TODO ADD anonymous key here
	%	A ring VRF is a VRF with a  function $ F(.):\{0,1\}^* \rightarrow \{0,1\}^{\ell_\rvrf} $ and with the following algorithms:
	%	
	%	\begin{itemize}
		%		\item $ \rvrf.\keygen(1^\kappa) \rightarrow (\skrvrf,\pk)$ where $ \kappa $ is the security parameter,
		%	\end{itemize}
	%	Given list of public keys $ \ring = \set{\pk_1, \pk_2, \ldots, \pk_n}$, a message $ m \in \{0,1\}^{\ell_m} $
	%	\begin{itemize}
		%		\item $ \rvrf.\eval(\skrvrf_i, \ring, m) \rightarrow y$
		%		\item $ \rvrf.\sign(\skrvrf_i, \ring, m)\rightarrow (\sigma,W) $ where  $\sigma $ is a signature of the message $ m $ signed by $ \skrvrf_i, \ring $ and $ W $ is an anonymous key.
		%		\item $ \rvrf.\verify(\ring,W, m,\sigma) \rightarrow  (b, y)$ where $ b \in \{0,1\} $ and $ y \in \{0,1\}^{\ell_\rvrf}\cup \{\perp\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
		%%		\item $ \rvrf.\link(\skrvrf_i, \ring,W,m, \sigma) \rightarrow \hat\sigma $ where  $ \hat\sigma $ is a signature that links signer of the ring signature $ \sigma $. 
		%%		\item $ \rvrf.\link\verify( \pk_i,\ring,W, m, \sigma, \hat\sigma)\rightarrow b$ where $ b \in \{0,1\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
		%	\end{itemize}
	%	
	%\end{definition}
