\section{Ring VRF construction}% {Ring VRFs from the Pedersen VRF}
\label{sec:pederson_vrf}

We now construct ring VRFs with an efficient evaluation proof, which
we call the Pedersen VRF and denote \PedVRF.
\PedVRF instantiates the NIZK for the relation $\Reval$ introduced in a general form in \S\ref{sec:overview}.
In this section we focus upon Pedersen VRF and relations describing its SNARK
for ring membership and we discuss the zero-knowledge continuation
that makes the overall ring VRF efficient in the next section.

We refer readers to \S\ref{sec:ec_background} for notation,
 like our curves and hash functions.
In particular miss-use resistance dictates \PedVRF be instantiated with
two elliptic curves: $\ecE$ (or $\ecE_1$) handles key commitments
 build with two independent base points $\genG$ and $\genB$,
We hash-to a ``sister'' Edwards curve $\ecEsis$ with a subgroup $\grEsis$
 of the same order $p$ as $\grE$.
In practice $\grEsis$ has cofactor $\hsis$ divisible by 4, while
 $\grE$ might have effective cofactor 1 if deserialization enforces subgroup checks.
Any readers only interested in theoretical security arguments
should assume $\ecEsis = \ecE$ and $\hsis = 1 = h$,
 while implementers should read more carefully.

\paragraph{Pedersen VRF:} 
We construct \PedVRF similarly to EC VRF
 \cite{nsec5,VXEd25519,draft-irtf-cfrg-vrf-10},
except we replace the public key by a Pedersen commitment
 $\sk \, \genG + \openpk \, \genB$ to the secret key \sk,
 were $\genG$ and $\genB$ are independent generators of $\grE$.

We do not expose a public key from \KeyGen, nor inject the public key in \Eval.
\begin{itemize}
    \item $\PedVRF.\KeyGen$ \, returns $\sk \leftsample \F_p$. % and $\pk = \sk \, \genG$.
    \item $\PedVRF.\Eval : (\sk,\msg) \mapsto H'(\msg, \hsis\,\PreOut)$ where $\PreOut = \sk \, H_{\grEsis}(\msg)$.
\end{itemize}
\noindent We instead add an algorithm to obtain a Pedersen commitment to the secret key \sk.
\begin{itemize}
    \item $\PedVRF.\CommitKey(\sk)$ \,
    returns a blinding factor $\openpk \leftsample \F_p$
    and a commitment $\compk = \sk \, \genG + \openpk \, \genB$.
    % \item $\PedVRF.\OpenKey(\compk,\openpk)$ \,
    % returns $\pk = \compk - \openpk \, \genB$.
    % \item $\PedVRF.\OpenKey(\sk,\openpk)$ \,
    % returns $\compk = \sk \, \genG + \openpk \, \genB$.
\end{itemize}
We do not expose an opening algorithm here because opening occurs inside
our zero knowledge continuation,
 as described in $\Rring$ and \S\ref{sec:rvrf_cont} below.

Our \Sign and \Verify algorithms of \PedVRF correspond to
the \Prove and \Verify algorithms of a Chaum-Pedersen DLEQ proof
 for relation $\mathcal{R}_{eval}$,
instantiated by a Fiat-Shamir transform of a sigma protocol.
$$ \mathcal{R}_{eval} = \Setst{
  \begin{aligned}
    & (\compk,\PreOut,\In) ; \\ 
    & \,\, (\sk, \openpk) 
  \end{aligned}
}{
  \begin{aligned}
    & \compk = \sk\,\genG + \openpk\,\genB, \\
    & \,\, \PreOut = \sk\,\In 
  \end{aligned}
}  \mathperiod \label{rel:commit} 
$$
%
\begin{itemize}
	\item $\PedVRF.\Sign : (\sk,\openpk,\msg,\aux) \mapsto \sigma$ \,
	% takes a secret key \sk and blinding factor \openpk, an input $\msg$, and associated data \aux, and then performs
    % $ \NIZK_{\mathcal{R}_{eval}}.\Prove(((\genG, \genB,\grE,\compk,\PreOut,\In); (\sk, \openpk))) $
    % $ \sigma = (\PreOut,\compk,\pi_{eval}) $
	First compute $\In := H_{\grEsis}(\msg)$ and $\PreOut := \sk \, \In$ and \compk.
	Next sample random $r_1,r_2 \leftsample \F_p$
	to compute $R = r_1 \genG + r_2 \genB$ and $R_m = r_1 \In$.
	Compute the challenge $c = H_p(\aux,\msg,\compk,\PreOut,R,R_m)$.
	Finally compute $s_1 = r_1 + c \, \sk$ and $s_2 = r_2 + c \, \openpk$.
	and return the signature $\sigma = (\PreOut,R,R_m,s_1,s_2)$.
	% and return the signature $\sigma = (\PreOut,c,s_1,s_2)$.

	\item $\PedVRF.\Verify : (\compk,\msg,\aux,\sigma) \mapsto \Out \,\, \lor \perp$ \,
	% $ \NIZK_{\mathcal{R}_{eval}}.\Verify(\genG, \genB,\grE,\compk,\PreOut,\In, \pi_{eval} ) $
	First parse $\sigma = (\PreOut, \pi_{eval} = (R,R_m,s_1,s_2))$,
	recomputes $\In := H_{\grEsis}(\msg)$ and 
	$c = H_p(\aux,\msg,\compk,\PreOut,R,R_m)$.
    Finally if $h \, R = h \, (s_1 \genG + s_2 \genB - c \, \compk)$ and
    and $h \, R_m = h \, (s_1 \In - c \, \PreOut)$ both hold,
	% First parse $\sigma = (\PreOut, \pi_{eval} =(c,s_1,s_2))$,
	% recompute $\In := H_{\grEsis}(\msg)$, 
    % $R = s_1 \genG + s_2 \genB - c \, \compk$, and
    % $R_m = s_1 \In - c \, \PreOut$.
    % Finally if $c = H_p(\aux,\msg,\compk,\PreOut,R,R_m)$ holds,
    then return $H(\msg, \hsis\,\PreOut)$, which equals $\PedVRF.\Eval(\sk,\msg)$,
    or return failure $\perp$ otherwise.
\end{itemize}
\noindent We described the deterministically batchable flavor analogous
to \cite{HdVBatchEd25519} because $s_2$ makes our signature large enough
that half-aggregation makes sense, unlike EC VRF.
We remark that\PedVRF becomes almost EC VRF if
 we demand $\openpk = 0 = r_2$ in \Sign,
but our public key handling in \PedVRF breaks VRF definitions somewhat.

\paragraph{The Ring VRF Construction:}
As described in \S\ref{sec:overview},
we instantiate \rVRF from \PedVRF plus a ring commitment scheme
 $\rVRF.\{ \CommitRing, \OpenRing \}$. $ \rVRF.\CommitRing(\ring,\pk) \rightarrow (\comring,\openring)$  outputs a Merkle tree root $\comring  $ and the Merkle tree path $ \openring $ that verifies $ \pk \in \ring $.
We choose the ring commitment scheme so the $\rVRF.\OpenRing$ invocation
is relatively SNARK friendly in our ring membership relation $ \Rring $. We note that a trivial ring commitment scheme where $ \comring = \ring $ and $ \openring = \pk $ works in our scheme as well.
% \vspace{-0.1in}

At this point, we need public keys for $\rVRF.\CommitRing$ of course,
but exactly what form these public keys take depends upon how our computation
 $\compk - \openpk \, \genB$ inside $\Rring$ works.
We therefore define $ \rVRF.\KeyGen $ as follows:

\begin{itemize}
	\item $\rVRF.\KeyGen$ \, returns as secret key $\sk,r \leftsample \F_p$ and $ \pk $ as public key where $ \pk = \mathsf{Com}.\mathsf{Commit}(\sk,r)  $. We note that $ \pk  $ can be defined as $ \pk = \sk \genG $ according to the SNARK used for $ \Rring $. In this case, we would not have $ r $ as a part of the secret key. We provide one optimal public key design in \S\ref{subsec:rvrf_faster} for our SNARK used for $ \Rring $. 
\end{itemize}

% have a relation $\overset{\sk}{\equiv}$ that proves the secret key $\sk$ behind $\pk$ matches $\sk \, \genG = \compk - \openpk \, \genB$.\\
 

 


	% although some further nuances only appear later in \S\ref{subsec:AML_KYC}.
	%Anyways $\rVRF.\KeyGen$ always generate both a secret key similar to
	%$\PedVRF.\KeyGen$ as well as some corresponding public key type
	% compatible with $\rVRF.\CommitRing$.
\begin{itemize}
\item $\rVRF.\Eval$ is defined identically to $\PedVRF.\Eval$.
\end{itemize}
Next, we instantiate  $ \Rring $ with
$$ \Rring = \Setst{ 
	\begin{aligned}
		& \,\, (\compk,\comring); \\ 
		& (\openpk, \openring, \pk, \sk, r) 
	\end{aligned}
}{
	\begin{aligned}
		 &((\sk, r);(\pk, \compk - \openpk \, \genB)) \in \rel_{\pk} \\
		\pk &= \rVRF.\OpenRing(\comring,\openring)
	\end{aligned}
} \mathperiod $$

where $\rel_{\pk} = \{(\pk, X);(\sk,r): \sk = \mathsf{Com}.\mathsf{Open}(\pk;\sk,r), X = \sk\genG\}$. \\

\noindent The \Sign and \Verify for  our \rVRF are a combination of \Sign and \Verify from \PedVRF and
\Prove and \Verify from $\NIZK_{\Rring}$, as follows:
\def\tmpaux{\aux \doubleplus \piring \doubleplus \comring}
\def\tmpeprintaux{\eprint{\aux'}{\tmpaux}}
\def\tmpindent{\hspace*{5pt}}
\begin{itemize}
	\item $\rVRF.\rSign : ((\sk,r),\comring, \openring,\msg,\aux) \mapsto \rho$
	returns a ring VRF signature $\rho = (\compk,\piring,\sigma)$
	if \openring is a correct opening of \comring.  In this, 
	\tmpindent $(\openpk,\compk) \leftarrow \PedVRF.\CommitKey(\sk)$,  \\
	\tmpindent $\piring \leftarrow \NIZK_{\Rring}.\Prove((\compk,\comring); \openpk,\openring, \pk,\sk,r)$, \\
	where 
	\tmpindent $\aux' \leftarrow \tmpaux$,  \\
	\tmpindent $\sigma \leftarrow \PedVRF.\Sign(\sk,\openpk,\msg, \aux')$.
		
	We note that if $ \pk = \sk\genG = X $ then $ \Rring $ does not need $ \sk,r $ since $ \rel_{\pk} $ can be checked without them i.e., the check corresponding to inclusion in the $\rel_{pk}$ relation 
	is covered by the check $ \compk - \openpk \genB = \rVRF.\OpenRing(\comring,\openring) $.
	\item $\rVRF.\rVerify : (\comring,\msg,\aux,\rho) \mapsto \Out \,\, \lor \perp$ \,
	parses $\rho$ as $(\compk,\piring,\sigma)$, next sets $\aux' \leftarrow \tmpaux$,
	aborts if $\NIZK_{\Rring}.\Verify((\compk,\comring); \piring)$ fails,
	and returns $\PedVRF.\Verify(\compk,\msg, \aux', \sigma)$.
\end{itemize}

% BEGIN TODO: Oana

% % Although \PedVRF itself exhibits surprising properties, our gestalt 
% \rVRF satisfies sensible security definitions:
% Pseudo-randomness holds by reduction to singleton rings.
% Ring uniqueness, ring unforgeability, and ring anonymity resemble security
% arguments for other ring signatures built from SNARKs.

% \begin{proposition}\label{prop:rvrf_games}
% $\rVRF$ satisfies ring uniqueness, ring unforgeability, and ring anonymity.
% \end{proposition}

% END TODO: Oana

Appendix \ref{ap:ucproof} proves our ring VRF construction realizes $ \fgvrf $ in Figure \ref{f:gvrf}. Intuitively, the randomness and the determinism of $ \rVRF.\Eval $ come from the random oracles $ H' $ and $ H_{\grE'} $.  The anonymity of our ring VRF signature comes from the perfect hiding property of Pedersen commitment, the zero-knowledge property of $ \NIZK_{\mathcal{R}_{ring}} $ (Lemma \ref{lem:anonymity}) and the difficulty of DDH in  $ \grE $ (Lemma \ref{lem:honestoutput}) so that $ \PreOut $ is indistinguishable from a random element in $ \grE $. The unforgeability and uniqueness come from the fact that CDH is hard in $ \grE $ (Lemma \ref{lem:simulation-ind}), i.e., for unforgeability,  one cannot commit an honest party's secret key without breaking the CDH problem and for the uniqueness,  if one can obtain $ \PedVRF $ signatures such that $ \sigma_1 = (\PreOut_1, \pi_{\PedVRF}) $ and $ \sigma_2 = (\PreOut_2, \pi'_{\PedVRF}) $ where  $ \PreOut_1 \neq \PreOut_2 $  and verified by \compk for the message \msg, then we break a CDH problem in $ \grE $.

\begin{theorem}\label{thm:rvrfmain}
$ \rVRF $  over the group structure $ (\grE,p,\genG,\genB) $ realizes $ \fgvrf $ in Figure \ref{f:gvrf} in the random oracle model assuming that $ \NIZK_{\mathcal{R}_{eval}} $ and $ \NIZK_{\mathcal{R}_{ring}}$ are zero-knowledge and knowledge sound, the decisional Diffie-Hellman (DDH) problem are hard in $ \grE  $ and the commitment scheme $ \mathsf{Com} $ is binding and perfectly hiding. 
\end{theorem}

% NOTE:  Is this redundant after the above paragraph?
% The security proof of Theorem \ref{thm:rvrfmain} is in Appendix \ref{ap:ucproof}.



\endinput

